""" Пишем сервер без фреймворков. Т.е. мы можем на голом сетевом уровне написать прогу на пайтоне которая:
- принимает http запрос
- видит и парсит все эти заголовки, разбирает их и подготавливает ответ."""
import socket # Это питоновская обертка, кот позволяет работать с сокетами.
from urllib import response

server = socket.create_server(('127.0.0.1', 8000))
""" Тут открываем порт на прослушивание. Т.е. у нас создается сокет-он состоит из пары ip и порт 
(т.е все запросы которые будут приходить на этот ip будут попадать в этот сокет на этот ip и на этот порт).
И мы сможем в сыром виде поработать с данными кот туда пришли."""

server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
""" Еще нужно такую настройку провести чтобы у нас порт освобождался после выхода из нашего приложения (файла). 
И мы могли снова запустить через секунду сервер, открыть этот сокет на этом же порту."""

server.listen(10)
""" Это длина очереди- сколько соединений слушаем.Когда к нам пришел запрос сетевой, мы с ним работаем:
устанавливаем соединение и еще 9 запросов у нас в очереди ожидают,если приходит 10 в этот момент, мы его не пускаем."""

try:
    while True:
    #добавляем бесконечный цикл чтобы сервер не отрубался а постоянно ждал клиентов и обрабатывал запросы
        client_socket, adress = server.accept()
        """ когда в наш сокет придет сетевое соединение/сет запрос, будет выполнена эта функция. server.accept() возвращает кортеж 
            и мы этот tuple распаковываем в 2 переменных. В переменную client_socket сохранится у нас объект для работы с этим сокетом, 
            т.е. мы в этот клиентский сокет сможем отправлять данные, читать из него данные (данные кот отправил нам клиент) 
            и adress это адрес клиента кот отправил нам запрос"""

        received_data = client_socket.recv(1024).decode('utf-8')
        """receive 1024 байта и декодируем это в utf8, потому что данные там читаются в байтовом виде, а мы хотим получить строки.  
        Если придет больше чем 1024 байта в клиентский сокет то мы таким образом их не прочитаем-все остальное отсеится."""

        print('Получили данные по сокету', received_data)
        path = received_data.split(' ')[1]
        # здесь будет ответ который мы хотим вернуть в браузер. Тут получается у нас минимальный объем заголовков - статус и Content Type.
        response = f"HTTP/1.1 200 OK\nContent-Type: text/html; charset=utf-8\n\n" \
                   f"Привеет!<br />Path: {path}"

        # отправляем эти данные в клиентский сокет, т.е. нашему браузеру, а браузер примет этот ответ и отобразит
        client_socket.send(response.encode('utf-8'))

        # выключаем сокет и далее закрываем.
        client_socket.shutdown(socket.SHUT_RDWR)


# обрабатываем исключение
except KeyboardInterrupt:
    server.shutdown(socket.SHUT_RDWR)
    server.close()









